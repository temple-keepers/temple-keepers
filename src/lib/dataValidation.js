/**\n * Data validation and sanitization utilities\n */\n\n// Validation schemas for different data types\nexport const schemas = {\n  user: {\n    email: {\n      required: true,\n      type: 'email',\n      maxLength: 255\n    },\n    full_name: {\n      required: true,\n      type: 'string',\n      minLength: 2,\n      maxLength: 100,\n      pattern: /^[a-zA-Z\\s'-]+$/\n    },\n    health_goals: {\n      type: 'array',\n      maxLength: 10,\n      items: {\n        type: 'string',\n        enum: ['weight_loss', 'muscle_gain', 'energy', 'sleep', 'spiritual_growth', 'meal_prep', 'hydration', 'stress_management']\n      }\n    },\n    dietary_preferences: {\n      type: 'array',\n      maxLength: 15,\n      items: {\n        type: 'string',\n        enum: ['vegetarian', 'vegan', 'pescatarian', 'gluten_free', 'dairy_free', 'low_carb', 'keto', 'paleo', 'whole30', 'low_fodmap', 'sugar_free', 'high_protein', 'nut_free', 'halal', 'kosher']\n      }\n    }\n  },\n  \n  recipe: {\n    title: {\n      required: true,\n      type: 'string',\n      minLength: 3,\n      maxLength: 100\n    },\n    description: {\n      type: 'string',\n      maxLength: 500\n    },\n    ingredients: {\n      required: true,\n      type: 'array',\n      minLength: 1,\n      maxLength: 30,\n      items: {\n        type: 'string',\n        minLength: 2,\n        maxLength: 200\n      }\n    },\n    instructions: {\n      required: true,\n      type: 'array',\n      minLength: 1,\n      maxLength: 20,\n      items: {\n        type: 'string',\n        minLength: 5,\n        maxLength: 500\n      }\n    },\n    prep_time: {\n      type: 'number',\n      min: 0,\n      max: 720 // 12 hours\n    },\n    cook_time: {\n      type: 'number',\n      min: 0,\n      max: 1440 // 24 hours\n    },\n    servings: {\n      type: 'number',\n      min: 1,\n      max: 50\n    },\n    calories: {\n      type: 'number',\n      min: 0,\n      max: 5000\n    },\n    meal_type: {\n      type: 'string',\n      enum: ['breakfast', 'lunch', 'dinner', 'snack', 'dessert', 'drink']\n    }\n  },\n  \n  post: {\n    content: {\n      required: true,\n      type: 'string',\n      minLength: 1,\n      maxLength: 2000\n    },\n    type: {\n      required: true,\n      type: 'string',\n      enum: ['update', 'win', 'encouragement', 'question', 'testimony']\n    },\n    is_anonymous: {\n      type: 'boolean',\n      default: false\n    }\n  },\n  \n  challenge: {\n    title: {\n      required: true,\n      type: 'string',\n      minLength: 3,\n      maxLength: 100\n    },\n    description: {\n      required: true,\n      type: 'string',\n      minLength: 10,\n      maxLength: 1000\n    },\n    duration_days: {\n      required: true,\n      type: 'number',\n      min: 1,\n      max: 365\n    },\n    difficulty: {\n      required: true,\n      type: 'string',\n      enum: ['beginner', 'intermediate', 'advanced']\n    },\n    category: {\n      required: true,\n      type: 'string',\n      enum: ['fitness', 'nutrition', 'spiritual', 'wellness', 'habits']\n    }\n  }\n}\n\n/**\n * Data type validators\n */\nconst validators = {\n  string: (value) => typeof value === 'string',\n  number: (value) => typeof value === 'number' && !isNaN(value),\n  boolean: (value) => typeof value === 'boolean',\n  array: (value) => Array.isArray(value),\n  email: (value) => {\n    if (typeof value !== 'string') return false\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n    return emailRegex.test(value)\n  },\n  url: (value) => {\n    if (typeof value !== 'string') return false\n    try {\n      new URL(value)\n      return true\n    } catch {\n      return false\n    }\n  },\n  uuid: (value) => {\n    if (typeof value !== 'string') return false\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\n    return uuidRegex.test(value)\n  }\n}\n\n/**\n * Sanitize string input\n */\nexport const sanitizeString = (value, options = {}) => {\n  if (typeof value !== 'string') return ''\n  \n  let sanitized = value\n  \n  // Trim whitespace\n  if (options.trim !== false) {\n    sanitized = sanitized.trim()\n  }\n  \n  // Remove multiple spaces\n  if (options.collapseSpaces) {\n    sanitized = sanitized.replace(/\\s+/g, ' ')\n  }\n  \n  // Remove HTML tags (basic)\n  if (options.stripHTML) {\n    sanitized = sanitized.replace(/<[^>]*>/g, '')\n  }\n  \n  // Escape HTML entities\n  if (options.escapeHTML) {\n    sanitized = sanitized\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#x27;')\n  }\n  \n  return sanitized\n}\n\n/**\n * Sanitize array input\n */\nexport const sanitizeArray = (value, options = {}) => {\n  if (!Array.isArray(value)) return []\n  \n  const { maxLength = 100, itemSanitizer = null } = options\n  \n  let sanitized = value.slice(0, maxLength) // Limit length\n  \n  if (itemSanitizer) {\n    sanitized = sanitized.map(itemSanitizer).filter(Boolean)\n  }\n  \n  // Remove duplicates if requested\n  if (options.unique) {\n    sanitized = [...new Set(sanitized)]\n  }\n  \n  return sanitized\n}\n\n/**\n * Validate a value against a field schema\n */\nexport const validateField = (value, fieldSchema, fieldName = 'field') => {\n  const errors = []\n  \n  // Required check\n  if (fieldSchema.required) {\n    if (value === null || value === undefined || value === '' || \n        (Array.isArray(value) && value.length === 0)) {\n      errors.push(`${fieldName} is required`)\n      return errors // Don't continue if required field is empty\n    }\n  }\n  \n  // Skip other validations if value is empty and not required\n  if (value === null || value === undefined || value === '') {\n    return errors\n  }\n  \n  // Type validation\n  if (fieldSchema.type) {\n    const validator = validators[fieldSchema.type]\n    if (validator && !validator(value)) {\n      errors.push(`${fieldName} must be a valid ${fieldSchema.type}`)\n      return errors // Don't continue if type is wrong\n    }\n  }\n  \n  // String-specific validations\n  if (typeof value === 'string') {\n    if (fieldSchema.minLength && value.length < fieldSchema.minLength) {\n      errors.push(`${fieldName} must be at least ${fieldSchema.minLength} characters`)\n    }\n    \n    if (fieldSchema.maxLength && value.length > fieldSchema.maxLength) {\n      errors.push(`${fieldName} must be no more than ${fieldSchema.maxLength} characters`)\n    }\n    \n    if (fieldSchema.pattern && !fieldSchema.pattern.test(value)) {\n      errors.push(`${fieldName} format is invalid`)\n    }\n  }\n  \n  // Number-specific validations\n  if (typeof value === 'number') {\n    if (fieldSchema.min !== undefined && value < fieldSchema.min) {\n      errors.push(`${fieldName} must be at least ${fieldSchema.min}`)\n    }\n    \n    if (fieldSchema.max !== undefined && value > fieldSchema.max) {\n      errors.push(`${fieldName} must be no more than ${fieldSchema.max}`)\n    }\n  }\n  \n  // Array-specific validations\n  if (Array.isArray(value)) {\n    if (fieldSchema.minLength && value.length < fieldSchema.minLength) {\n      errors.push(`${fieldName} must have at least ${fieldSchema.minLength} items`)\n    }\n    \n    if (fieldSchema.maxLength && value.length > fieldSchema.maxLength) {\n      errors.push(`${fieldName} must have no more than ${fieldSchema.maxLength} items`)\n    }\n    \n    // Validate array items\n    if (fieldSchema.items) {\n      value.forEach((item, index) => {\n        const itemErrors = validateField(item, fieldSchema.items, `${fieldName}[${index}]`)\n        errors.push(...itemErrors)\n      })\n    }\n  }\n  \n  // Enum validation\n  if (fieldSchema.enum && !fieldSchema.enum.includes(value)) {\n    errors.push(`${fieldName} must be one of: ${fieldSchema.enum.join(', ')}`)\n  }\n  \n  return errors\n}\n\n/**\n * Validate an entire object against a schema\n */\nexport const validateData = (data, schemaName) => {\n  const schema = schemas[schemaName]\n  if (!schema) {\n    throw new Error(`Unknown schema: ${schemaName}`)\n  }\n  \n  const errors = {}\n  let isValid = true\n  \n  // Validate each field in the schema\n  Object.keys(schema).forEach(fieldName => {\n    const fieldSchema = schema[fieldName]\n    const fieldValue = data[fieldName]\n    \n    const fieldErrors = validateField(fieldValue, fieldSchema, fieldName)\n    \n    if (fieldErrors.length > 0) {\n      errors[fieldName] = fieldErrors\n      isValid = false\n    }\n  })\n  \n  return {\n    isValid,\n    errors,\n    firstError: isValid ? null : Object.values(errors).flat()[0]\n  }\n}\n\n/**\n * Sanitize data according to schema\n */\nexport const sanitizeData = (data, schemaName) => {\n  const schema = schemas[schemaName]\n  if (!schema) {\n    throw new Error(`Unknown schema: ${schemaName}`)\n  }\n  \n  const sanitized = {}\n  \n  Object.keys(schema).forEach(fieldName => {\n    const fieldSchema = schema[fieldName]\n    const fieldValue = data[fieldName]\n    \n    if (fieldValue === undefined || fieldValue === null) {\n      if (fieldSchema.default !== undefined) {\n        sanitized[fieldName] = fieldSchema.default\n      }\n      return\n    }\n    \n    switch (fieldSchema.type) {\n      case 'string':\n      case 'email':\n        sanitized[fieldName] = sanitizeString(fieldValue, {\n          trim: true,\n          collapseSpaces: true,\n          stripHTML: true\n        })\n        break\n        \n      case 'array':\n        sanitized[fieldName] = sanitizeArray(fieldValue, {\n          maxLength: fieldSchema.maxLength,\n          unique: true,\n          itemSanitizer: (item) => {\n            if (fieldSchema.items?.type === 'string') {\n              return sanitizeString(item, { trim: true })\n            }\n            return item\n          }\n        })\n        break\n        \n      case 'number':\n        const num = Number(fieldValue)\n        if (!isNaN(num)) {\n          sanitized[fieldName] = num\n        }\n        break\n        \n      case 'boolean':\n        sanitized[fieldName] = Boolean(fieldValue)\n        break\n        \n      default:\n        sanitized[fieldName] = fieldValue\n    }\n  })\n  \n  return sanitized\n}\n\n/**\n * Higher-order function to validate and sanitize API input\n */\nexport const withDataValidation = (schemaName, options = {}) => {\n  const { sanitize = true, throwOnError = true } = options\n  \n  return (fn) => {\n    return async (data, ...args) => {\n      // Sanitize first if requested\n      const processedData = sanitize ? sanitizeData(data, schemaName) : data\n      \n      // Validate\n      const validation = validateData(processedData, schemaName)\n      \n      if (!validation.isValid) {\n        const error = new Error(validation.firstError)\n        error.name = 'ValidationError'\n        error.errors = validation.errors\n        \n        if (throwOnError) {\n          throw error\n        } else {\n          console.warn('Validation failed:', validation.errors)\n        }\n      }\n      \n      return fn(processedData, ...args)\n    }\n  }\n}\n\nexport default validateData